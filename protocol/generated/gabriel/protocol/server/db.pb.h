// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gabriel/protocol/server/db.proto

#ifndef PROTOBUF_gabriel_2fprotocol_2fserver_2fdb_2eproto__INCLUDED
#define PROTOBUF_gabriel_2fprotocol_2fserver_2fdb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gabriel/protocol/shared.pb.h"
#include "gabriel/protocol/pub.pb.h"
// @@protoc_insertion_point(includes)

namespace gabriel {
namespace protocol {
namespace server {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
void protobuf_AssignDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
void protobuf_ShutdownFile_gabriel_2fprotocol_2fserver_2fdb_2eproto();

class Monster;
class Outer;
class Outer_Inner;
class DB_Msg;

enum Outer_InnerEnum {
  Outer_InnerEnum_ENUM_INNER_1 = 99,
  Outer_InnerEnum_ENUM_INNER_2 = 98,
  Outer_InnerEnum_ENUM_INNER_3 = 102
};
bool Outer_InnerEnum_IsValid(int value);
const Outer_InnerEnum Outer_InnerEnum_InnerEnum_MIN = Outer_InnerEnum_ENUM_INNER_2;
const Outer_InnerEnum Outer_InnerEnum_InnerEnum_MAX = Outer_InnerEnum_ENUM_INNER_3;
const int Outer_InnerEnum_InnerEnum_ARRAYSIZE = Outer_InnerEnum_InnerEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* Outer_InnerEnum_descriptor();
inline const ::std::string& Outer_InnerEnum_Name(Outer_InnerEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    Outer_InnerEnum_descriptor(), value);
}
inline bool Outer_InnerEnum_Parse(
    const ::std::string& name, Outer_InnerEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Outer_InnerEnum>(
    Outer_InnerEnum_descriptor(), name, value);
}
enum OuterEnum {
  ENUM_OUTER_1 = 5,
  ENUM_OUTER_2 = 6,
  ENUM_OUTER_3 = 7
};
bool OuterEnum_IsValid(int value);
const OuterEnum OuterEnum_MIN = ENUM_OUTER_1;
const OuterEnum OuterEnum_MAX = ENUM_OUTER_3;
const int OuterEnum_ARRAYSIZE = OuterEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OuterEnum_descriptor();
inline const ::std::string& OuterEnum_Name(OuterEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OuterEnum_descriptor(), value);
}
inline bool OuterEnum_Parse(
    const ::std::string& name, OuterEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OuterEnum>(
    OuterEnum_descriptor(), name, value);
}
// ===================================================================

class Monster : public ::google::protobuf::Message {
 public:
  Monster();
  virtual ~Monster();

  Monster(const Monster& from);

  inline Monster& operator=(const Monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Monster& default_instance();

  void Swap(Monster* other);

  // implements Message ----------------------------------------------

  Monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Monster& from);
  void MergeFrom(const Monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 monster_id = 1;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 1;
  inline ::google::protobuf::int32 monster_id() const;
  inline void set_monster_id(::google::protobuf::int32 value);

  // optional int32 monster_hp = 2;
  inline bool has_monster_hp() const;
  inline void clear_monster_hp();
  static const int kMonsterHpFieldNumber = 2;
  inline ::google::protobuf::int32 monster_hp() const;
  inline void set_monster_hp(::google::protobuf::int32 value);

  // optional string monster_name = 3;
  inline bool has_monster_name() const;
  inline void clear_monster_name();
  static const int kMonsterNameFieldNumber = 3;
  inline const ::std::string& monster_name() const;
  inline void set_monster_name(const ::std::string& value);
  inline void set_monster_name(const char* value);
  inline void set_monster_name(const char* value, size_t size);
  inline ::std::string* mutable_monster_name();
  inline ::std::string* release_monster_name();
  inline void set_allocated_monster_name(::std::string* monster_name);

  // @@protoc_insertion_point(class_scope:gabriel.protocol.server.Monster)
 private:
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_monster_hp();
  inline void clear_has_monster_hp();
  inline void set_has_monster_name();
  inline void clear_has_monster_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 monster_id_;
  ::google::protobuf::int32 monster_hp_;
  ::std::string* monster_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_AssignDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_ShutdownFile_gabriel_2fprotocol_2fserver_2fdb_2eproto();

  void InitAsDefaultInstance();
  static Monster* default_instance_;
};
// -------------------------------------------------------------------

class Outer_Inner : public ::google::protobuf::Message {
 public:
  Outer_Inner();
  virtual ~Outer_Inner();

  Outer_Inner(const Outer_Inner& from);

  inline Outer_Inner& operator=(const Outer_Inner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Outer_Inner& default_instance();

  void Swap(Outer_Inner* other);

  // implements Message ----------------------------------------------

  Outer_Inner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Outer_Inner& from);
  void MergeFrom(const Outer_Inner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 inner_id = 1;
  inline bool has_inner_id() const;
  inline void clear_inner_id();
  static const int kInnerIdFieldNumber = 1;
  inline ::google::protobuf::int32 inner_id() const;
  inline void set_inner_id(::google::protobuf::int32 value);

  // optional string inner_string = 2;
  inline bool has_inner_string() const;
  inline void clear_inner_string();
  static const int kInnerStringFieldNumber = 2;
  inline const ::std::string& inner_string() const;
  inline void set_inner_string(const ::std::string& value);
  inline void set_inner_string(const char* value);
  inline void set_inner_string(const char* value, size_t size);
  inline ::std::string* mutable_inner_string();
  inline ::std::string* release_inner_string();
  inline void set_allocated_inner_string(::std::string* inner_string);

  // @@protoc_insertion_point(class_scope:gabriel.protocol.server.Outer.Inner)
 private:
  inline void set_has_inner_id();
  inline void clear_has_inner_id();
  inline void set_has_inner_string();
  inline void clear_has_inner_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* inner_string_;
  ::google::protobuf::int32 inner_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_AssignDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_ShutdownFile_gabriel_2fprotocol_2fserver_2fdb_2eproto();

  void InitAsDefaultInstance();
  static Outer_Inner* default_instance_;
};
// -------------------------------------------------------------------

class Outer : public ::google::protobuf::Message {
 public:
  Outer();
  virtual ~Outer();

  Outer(const Outer& from);

  inline Outer& operator=(const Outer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Outer& default_instance();

  void Swap(Outer* other);

  // implements Message ----------------------------------------------

  Outer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Outer& from);
  void MergeFrom(const Outer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Outer_Inner Inner;

  typedef Outer_InnerEnum InnerEnum;
  static const InnerEnum ENUM_INNER_1 = Outer_InnerEnum_ENUM_INNER_1;
  static const InnerEnum ENUM_INNER_2 = Outer_InnerEnum_ENUM_INNER_2;
  static const InnerEnum ENUM_INNER_3 = Outer_InnerEnum_ENUM_INNER_3;
  static inline bool InnerEnum_IsValid(int value) {
    return Outer_InnerEnum_IsValid(value);
  }
  static const InnerEnum InnerEnum_MIN =
    Outer_InnerEnum_InnerEnum_MIN;
  static const InnerEnum InnerEnum_MAX =
    Outer_InnerEnum_InnerEnum_MAX;
  static const int InnerEnum_ARRAYSIZE =
    Outer_InnerEnum_InnerEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InnerEnum_descriptor() {
    return Outer_InnerEnum_descriptor();
  }
  static inline const ::std::string& InnerEnum_Name(InnerEnum value) {
    return Outer_InnerEnum_Name(value);
  }
  static inline bool InnerEnum_Parse(const ::std::string& name,
      InnerEnum* value) {
    return Outer_InnerEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 outer_id = 1;
  inline bool has_outer_id() const;
  inline void clear_outer_id();
  static const int kOuterIdFieldNumber = 1;
  inline ::google::protobuf::int32 outer_id() const;
  inline void set_outer_id(::google::protobuf::int32 value);

  // optional string outer_string = 2;
  inline bool has_outer_string() const;
  inline void clear_outer_string();
  static const int kOuterStringFieldNumber = 2;
  inline const ::std::string& outer_string() const;
  inline void set_outer_string(const ::std::string& value);
  inline void set_outer_string(const char* value);
  inline void set_outer_string(const char* value, size_t size);
  inline ::std::string* mutable_outer_string();
  inline ::std::string* release_outer_string();
  inline void set_allocated_outer_string(::std::string* outer_string);

  // @@protoc_insertion_point(class_scope:gabriel.protocol.server.Outer)
 private:
  inline void set_has_outer_id();
  inline void clear_has_outer_id();
  inline void set_has_outer_string();
  inline void clear_has_outer_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* outer_string_;
  ::google::protobuf::int32 outer_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_AssignDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_ShutdownFile_gabriel_2fprotocol_2fserver_2fdb_2eproto();

  void InitAsDefaultInstance();
  static Outer* default_instance_;
};
// -------------------------------------------------------------------

class DB_Msg : public ::google::protobuf::Message {
 public:
  DB_Msg();
  virtual ~DB_Msg();

  DB_Msg(const DB_Msg& from);

  inline DB_Msg& operator=(const DB_Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DB_Msg& default_instance();

  void Swap(DB_Msg* other);

  // implements Message ----------------------------------------------

  DB_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DB_Msg& from);
  void MergeFrom(const DB_Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 dbmsg_id = 1;
  inline bool has_dbmsg_id() const;
  inline void clear_dbmsg_id();
  static const int kDbmsgIdFieldNumber = 1;
  inline ::google::protobuf::int32 dbmsg_id() const;
  inline void set_dbmsg_id(::google::protobuf::int32 value);

  // optional .gabriel.protocol.server.Monster monster = 2;
  inline bool has_monster() const;
  inline void clear_monster();
  static const int kMonsterFieldNumber = 2;
  inline const ::gabriel::protocol::server::Monster& monster() const;
  inline ::gabriel::protocol::server::Monster* mutable_monster();
  inline ::gabriel::protocol::server::Monster* release_monster();
  inline void set_allocated_monster(::gabriel::protocol::server::Monster* monster);

  // optional .gabriel.protocol.server.OuterEnum outerenum = 3;
  inline bool has_outerenum() const;
  inline void clear_outerenum();
  static const int kOuterenumFieldNumber = 3;
  inline ::gabriel::protocol::server::OuterEnum outerenum() const;
  inline void set_outerenum(::gabriel::protocol::server::OuterEnum value);

  // optional .gabriel.protocol.server.Outer outer = 4;
  inline bool has_outer() const;
  inline void clear_outer();
  static const int kOuterFieldNumber = 4;
  inline const ::gabriel::protocol::server::Outer& outer() const;
  inline ::gabriel::protocol::server::Outer* mutable_outer();
  inline ::gabriel::protocol::server::Outer* release_outer();
  inline void set_allocated_outer(::gabriel::protocol::server::Outer* outer);

  // optional .gabriel.protocol.server.Outer.InnerEnum innerenum = 5;
  inline bool has_innerenum() const;
  inline void clear_innerenum();
  static const int kInnerenumFieldNumber = 5;
  inline ::gabriel::protocol::server::Outer_InnerEnum innerenum() const;
  inline void set_innerenum(::gabriel::protocol::server::Outer_InnerEnum value);

  // optional .gabriel.protocol.server.Outer.Inner inner = 6;
  inline bool has_inner() const;
  inline void clear_inner();
  static const int kInnerFieldNumber = 6;
  inline const ::gabriel::protocol::server::Outer_Inner& inner() const;
  inline ::gabriel::protocol::server::Outer_Inner* mutable_inner();
  inline ::gabriel::protocol::server::Outer_Inner* release_inner();
  inline void set_allocated_inner(::gabriel::protocol::server::Outer_Inner* inner);

  // optional .gabriel.protocol.PubMsg pubmsg = 7;
  inline bool has_pubmsg() const;
  inline void clear_pubmsg();
  static const int kPubmsgFieldNumber = 7;
  inline const ::gabriel::protocol::PubMsg& pubmsg() const;
  inline ::gabriel::protocol::PubMsg* mutable_pubmsg();
  inline ::gabriel::protocol::PubMsg* release_pubmsg();
  inline void set_allocated_pubmsg(::gabriel::protocol::PubMsg* pubmsg);

  // optional .gabriel.protocol.PubEnum pubenum = 8;
  inline bool has_pubenum() const;
  inline void clear_pubenum();
  static const int kPubenumFieldNumber = 8;
  inline ::gabriel::protocol::PubEnum pubenum() const;
  inline void set_pubenum(::gabriel::protocol::PubEnum value);

  // optional .gabriel.protocol.PubOuter pubouter = 9;
  inline bool has_pubouter() const;
  inline void clear_pubouter();
  static const int kPubouterFieldNumber = 9;
  inline const ::gabriel::protocol::PubOuter& pubouter() const;
  inline ::gabriel::protocol::PubOuter* mutable_pubouter();
  inline ::gabriel::protocol::PubOuter* release_pubouter();
  inline void set_allocated_pubouter(::gabriel::protocol::PubOuter* pubouter);

  // optional .gabriel.protocol.PubOuter.PubInner pubinner = 10;
  inline bool has_pubinner() const;
  inline void clear_pubinner();
  static const int kPubinnerFieldNumber = 10;
  inline const ::gabriel::protocol::PubOuter_PubInner& pubinner() const;
  inline ::gabriel::protocol::PubOuter_PubInner* mutable_pubinner();
  inline ::gabriel::protocol::PubOuter_PubInner* release_pubinner();
  inline void set_allocated_pubinner(::gabriel::protocol::PubOuter_PubInner* pubinner);

  // optional .gabriel.protocol.PubOuter.PubInnerEnum pubinnerenum = 11;
  inline bool has_pubinnerenum() const;
  inline void clear_pubinnerenum();
  static const int kPubinnerenumFieldNumber = 11;
  inline ::gabriel::protocol::PubOuter_PubInnerEnum pubinnerenum() const;
  inline void set_pubinnerenum(::gabriel::protocol::PubOuter_PubInnerEnum value);

  // optional .gabriel.protocol.OnePubMsg onepubmsg = 12;
  inline bool has_onepubmsg() const;
  inline void clear_onepubmsg();
  static const int kOnepubmsgFieldNumber = 12;
  inline const ::gabriel::protocol::OnePubMsg& onepubmsg() const;
  inline ::gabriel::protocol::OnePubMsg* mutable_onepubmsg();
  inline ::gabriel::protocol::OnePubMsg* release_onepubmsg();
  inline void set_allocated_onepubmsg(::gabriel::protocol::OnePubMsg* onepubmsg);

  // @@protoc_insertion_point(class_scope:gabriel.protocol.server.DB_Msg)
 private:
  inline void set_has_dbmsg_id();
  inline void clear_has_dbmsg_id();
  inline void set_has_monster();
  inline void clear_has_monster();
  inline void set_has_outerenum();
  inline void clear_has_outerenum();
  inline void set_has_outer();
  inline void clear_has_outer();
  inline void set_has_innerenum();
  inline void clear_has_innerenum();
  inline void set_has_inner();
  inline void clear_has_inner();
  inline void set_has_pubmsg();
  inline void clear_has_pubmsg();
  inline void set_has_pubenum();
  inline void clear_has_pubenum();
  inline void set_has_pubouter();
  inline void clear_has_pubouter();
  inline void set_has_pubinner();
  inline void clear_has_pubinner();
  inline void set_has_pubinnerenum();
  inline void clear_has_pubinnerenum();
  inline void set_has_onepubmsg();
  inline void clear_has_onepubmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::gabriel::protocol::server::Monster* monster_;
  ::google::protobuf::int32 dbmsg_id_;
  int outerenum_;
  ::gabriel::protocol::server::Outer* outer_;
  ::gabriel::protocol::server::Outer_Inner* inner_;
  int innerenum_;
  int pubenum_;
  ::gabriel::protocol::PubMsg* pubmsg_;
  ::gabriel::protocol::PubOuter* pubouter_;
  ::gabriel::protocol::PubOuter_PubInner* pubinner_;
  ::gabriel::protocol::OnePubMsg* onepubmsg_;
  int pubinnerenum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_AssignDesc_gabriel_2fprotocol_2fserver_2fdb_2eproto();
  friend void protobuf_ShutdownFile_gabriel_2fprotocol_2fserver_2fdb_2eproto();

  void InitAsDefaultInstance();
  static DB_Msg* default_instance_;
};
// ===================================================================


// ===================================================================

// Monster

// optional int32 monster_id = 1;
inline bool Monster::has_monster_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Monster::set_has_monster_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Monster::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Monster::clear_monster_id() {
  monster_id_ = 0;
  clear_has_monster_id();
}
inline ::google::protobuf::int32 Monster::monster_id() const {
  return monster_id_;
}
inline void Monster::set_monster_id(::google::protobuf::int32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// optional int32 monster_hp = 2;
inline bool Monster::has_monster_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Monster::set_has_monster_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Monster::clear_has_monster_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Monster::clear_monster_hp() {
  monster_hp_ = 0;
  clear_has_monster_hp();
}
inline ::google::protobuf::int32 Monster::monster_hp() const {
  return monster_hp_;
}
inline void Monster::set_monster_hp(::google::protobuf::int32 value) {
  set_has_monster_hp();
  monster_hp_ = value;
}

// optional string monster_name = 3;
inline bool Monster::has_monster_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Monster::set_has_monster_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Monster::clear_has_monster_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Monster::clear_monster_name() {
  if (monster_name_ != &::google::protobuf::internal::kEmptyString) {
    monster_name_->clear();
  }
  clear_has_monster_name();
}
inline const ::std::string& Monster::monster_name() const {
  return *monster_name_;
}
inline void Monster::set_monster_name(const ::std::string& value) {
  set_has_monster_name();
  if (monster_name_ == &::google::protobuf::internal::kEmptyString) {
    monster_name_ = new ::std::string;
  }
  monster_name_->assign(value);
}
inline void Monster::set_monster_name(const char* value) {
  set_has_monster_name();
  if (monster_name_ == &::google::protobuf::internal::kEmptyString) {
    monster_name_ = new ::std::string;
  }
  monster_name_->assign(value);
}
inline void Monster::set_monster_name(const char* value, size_t size) {
  set_has_monster_name();
  if (monster_name_ == &::google::protobuf::internal::kEmptyString) {
    monster_name_ = new ::std::string;
  }
  monster_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Monster::mutable_monster_name() {
  set_has_monster_name();
  if (monster_name_ == &::google::protobuf::internal::kEmptyString) {
    monster_name_ = new ::std::string;
  }
  return monster_name_;
}
inline ::std::string* Monster::release_monster_name() {
  clear_has_monster_name();
  if (monster_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monster_name_;
    monster_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Monster::set_allocated_monster_name(::std::string* monster_name) {
  if (monster_name_ != &::google::protobuf::internal::kEmptyString) {
    delete monster_name_;
  }
  if (monster_name) {
    set_has_monster_name();
    monster_name_ = monster_name;
  } else {
    clear_has_monster_name();
    monster_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Outer_Inner

// optional int32 inner_id = 1;
inline bool Outer_Inner::has_inner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Outer_Inner::set_has_inner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Outer_Inner::clear_has_inner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Outer_Inner::clear_inner_id() {
  inner_id_ = 0;
  clear_has_inner_id();
}
inline ::google::protobuf::int32 Outer_Inner::inner_id() const {
  return inner_id_;
}
inline void Outer_Inner::set_inner_id(::google::protobuf::int32 value) {
  set_has_inner_id();
  inner_id_ = value;
}

// optional string inner_string = 2;
inline bool Outer_Inner::has_inner_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Outer_Inner::set_has_inner_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Outer_Inner::clear_has_inner_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Outer_Inner::clear_inner_string() {
  if (inner_string_ != &::google::protobuf::internal::kEmptyString) {
    inner_string_->clear();
  }
  clear_has_inner_string();
}
inline const ::std::string& Outer_Inner::inner_string() const {
  return *inner_string_;
}
inline void Outer_Inner::set_inner_string(const ::std::string& value) {
  set_has_inner_string();
  if (inner_string_ == &::google::protobuf::internal::kEmptyString) {
    inner_string_ = new ::std::string;
  }
  inner_string_->assign(value);
}
inline void Outer_Inner::set_inner_string(const char* value) {
  set_has_inner_string();
  if (inner_string_ == &::google::protobuf::internal::kEmptyString) {
    inner_string_ = new ::std::string;
  }
  inner_string_->assign(value);
}
inline void Outer_Inner::set_inner_string(const char* value, size_t size) {
  set_has_inner_string();
  if (inner_string_ == &::google::protobuf::internal::kEmptyString) {
    inner_string_ = new ::std::string;
  }
  inner_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Outer_Inner::mutable_inner_string() {
  set_has_inner_string();
  if (inner_string_ == &::google::protobuf::internal::kEmptyString) {
    inner_string_ = new ::std::string;
  }
  return inner_string_;
}
inline ::std::string* Outer_Inner::release_inner_string() {
  clear_has_inner_string();
  if (inner_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inner_string_;
    inner_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Outer_Inner::set_allocated_inner_string(::std::string* inner_string) {
  if (inner_string_ != &::google::protobuf::internal::kEmptyString) {
    delete inner_string_;
  }
  if (inner_string) {
    set_has_inner_string();
    inner_string_ = inner_string;
  } else {
    clear_has_inner_string();
    inner_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Outer

// optional int32 outer_id = 1;
inline bool Outer::has_outer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Outer::set_has_outer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Outer::clear_has_outer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Outer::clear_outer_id() {
  outer_id_ = 0;
  clear_has_outer_id();
}
inline ::google::protobuf::int32 Outer::outer_id() const {
  return outer_id_;
}
inline void Outer::set_outer_id(::google::protobuf::int32 value) {
  set_has_outer_id();
  outer_id_ = value;
}

// optional string outer_string = 2;
inline bool Outer::has_outer_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Outer::set_has_outer_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Outer::clear_has_outer_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Outer::clear_outer_string() {
  if (outer_string_ != &::google::protobuf::internal::kEmptyString) {
    outer_string_->clear();
  }
  clear_has_outer_string();
}
inline const ::std::string& Outer::outer_string() const {
  return *outer_string_;
}
inline void Outer::set_outer_string(const ::std::string& value) {
  set_has_outer_string();
  if (outer_string_ == &::google::protobuf::internal::kEmptyString) {
    outer_string_ = new ::std::string;
  }
  outer_string_->assign(value);
}
inline void Outer::set_outer_string(const char* value) {
  set_has_outer_string();
  if (outer_string_ == &::google::protobuf::internal::kEmptyString) {
    outer_string_ = new ::std::string;
  }
  outer_string_->assign(value);
}
inline void Outer::set_outer_string(const char* value, size_t size) {
  set_has_outer_string();
  if (outer_string_ == &::google::protobuf::internal::kEmptyString) {
    outer_string_ = new ::std::string;
  }
  outer_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Outer::mutable_outer_string() {
  set_has_outer_string();
  if (outer_string_ == &::google::protobuf::internal::kEmptyString) {
    outer_string_ = new ::std::string;
  }
  return outer_string_;
}
inline ::std::string* Outer::release_outer_string() {
  clear_has_outer_string();
  if (outer_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outer_string_;
    outer_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Outer::set_allocated_outer_string(::std::string* outer_string) {
  if (outer_string_ != &::google::protobuf::internal::kEmptyString) {
    delete outer_string_;
  }
  if (outer_string) {
    set_has_outer_string();
    outer_string_ = outer_string;
  } else {
    clear_has_outer_string();
    outer_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DB_Msg

// optional int32 dbmsg_id = 1;
inline bool DB_Msg::has_dbmsg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DB_Msg::set_has_dbmsg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DB_Msg::clear_has_dbmsg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DB_Msg::clear_dbmsg_id() {
  dbmsg_id_ = 0;
  clear_has_dbmsg_id();
}
inline ::google::protobuf::int32 DB_Msg::dbmsg_id() const {
  return dbmsg_id_;
}
inline void DB_Msg::set_dbmsg_id(::google::protobuf::int32 value) {
  set_has_dbmsg_id();
  dbmsg_id_ = value;
}

// optional .gabriel.protocol.server.Monster monster = 2;
inline bool DB_Msg::has_monster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DB_Msg::set_has_monster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DB_Msg::clear_has_monster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DB_Msg::clear_monster() {
  if (monster_ != NULL) monster_->::gabriel::protocol::server::Monster::Clear();
  clear_has_monster();
}
inline const ::gabriel::protocol::server::Monster& DB_Msg::monster() const {
  return monster_ != NULL ? *monster_ : *default_instance_->monster_;
}
inline ::gabriel::protocol::server::Monster* DB_Msg::mutable_monster() {
  set_has_monster();
  if (monster_ == NULL) monster_ = new ::gabriel::protocol::server::Monster;
  return monster_;
}
inline ::gabriel::protocol::server::Monster* DB_Msg::release_monster() {
  clear_has_monster();
  ::gabriel::protocol::server::Monster* temp = monster_;
  monster_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_monster(::gabriel::protocol::server::Monster* monster) {
  delete monster_;
  monster_ = monster;
  if (monster) {
    set_has_monster();
  } else {
    clear_has_monster();
  }
}

// optional .gabriel.protocol.server.OuterEnum outerenum = 3;
inline bool DB_Msg::has_outerenum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DB_Msg::set_has_outerenum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DB_Msg::clear_has_outerenum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DB_Msg::clear_outerenum() {
  outerenum_ = 5;
  clear_has_outerenum();
}
inline ::gabriel::protocol::server::OuterEnum DB_Msg::outerenum() const {
  return static_cast< ::gabriel::protocol::server::OuterEnum >(outerenum_);
}
inline void DB_Msg::set_outerenum(::gabriel::protocol::server::OuterEnum value) {
  assert(::gabriel::protocol::server::OuterEnum_IsValid(value));
  set_has_outerenum();
  outerenum_ = value;
}

// optional .gabriel.protocol.server.Outer outer = 4;
inline bool DB_Msg::has_outer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DB_Msg::set_has_outer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DB_Msg::clear_has_outer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DB_Msg::clear_outer() {
  if (outer_ != NULL) outer_->::gabriel::protocol::server::Outer::Clear();
  clear_has_outer();
}
inline const ::gabriel::protocol::server::Outer& DB_Msg::outer() const {
  return outer_ != NULL ? *outer_ : *default_instance_->outer_;
}
inline ::gabriel::protocol::server::Outer* DB_Msg::mutable_outer() {
  set_has_outer();
  if (outer_ == NULL) outer_ = new ::gabriel::protocol::server::Outer;
  return outer_;
}
inline ::gabriel::protocol::server::Outer* DB_Msg::release_outer() {
  clear_has_outer();
  ::gabriel::protocol::server::Outer* temp = outer_;
  outer_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_outer(::gabriel::protocol::server::Outer* outer) {
  delete outer_;
  outer_ = outer;
  if (outer) {
    set_has_outer();
  } else {
    clear_has_outer();
  }
}

// optional .gabriel.protocol.server.Outer.InnerEnum innerenum = 5;
inline bool DB_Msg::has_innerenum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DB_Msg::set_has_innerenum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DB_Msg::clear_has_innerenum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DB_Msg::clear_innerenum() {
  innerenum_ = 99;
  clear_has_innerenum();
}
inline ::gabriel::protocol::server::Outer_InnerEnum DB_Msg::innerenum() const {
  return static_cast< ::gabriel::protocol::server::Outer_InnerEnum >(innerenum_);
}
inline void DB_Msg::set_innerenum(::gabriel::protocol::server::Outer_InnerEnum value) {
  assert(::gabriel::protocol::server::Outer_InnerEnum_IsValid(value));
  set_has_innerenum();
  innerenum_ = value;
}

// optional .gabriel.protocol.server.Outer.Inner inner = 6;
inline bool DB_Msg::has_inner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DB_Msg::set_has_inner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DB_Msg::clear_has_inner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DB_Msg::clear_inner() {
  if (inner_ != NULL) inner_->::gabriel::protocol::server::Outer_Inner::Clear();
  clear_has_inner();
}
inline const ::gabriel::protocol::server::Outer_Inner& DB_Msg::inner() const {
  return inner_ != NULL ? *inner_ : *default_instance_->inner_;
}
inline ::gabriel::protocol::server::Outer_Inner* DB_Msg::mutable_inner() {
  set_has_inner();
  if (inner_ == NULL) inner_ = new ::gabriel::protocol::server::Outer_Inner;
  return inner_;
}
inline ::gabriel::protocol::server::Outer_Inner* DB_Msg::release_inner() {
  clear_has_inner();
  ::gabriel::protocol::server::Outer_Inner* temp = inner_;
  inner_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_inner(::gabriel::protocol::server::Outer_Inner* inner) {
  delete inner_;
  inner_ = inner;
  if (inner) {
    set_has_inner();
  } else {
    clear_has_inner();
  }
}

// optional .gabriel.protocol.PubMsg pubmsg = 7;
inline bool DB_Msg::has_pubmsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DB_Msg::set_has_pubmsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DB_Msg::clear_has_pubmsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DB_Msg::clear_pubmsg() {
  if (pubmsg_ != NULL) pubmsg_->::gabriel::protocol::PubMsg::Clear();
  clear_has_pubmsg();
}
inline const ::gabriel::protocol::PubMsg& DB_Msg::pubmsg() const {
  return pubmsg_ != NULL ? *pubmsg_ : *default_instance_->pubmsg_;
}
inline ::gabriel::protocol::PubMsg* DB_Msg::mutable_pubmsg() {
  set_has_pubmsg();
  if (pubmsg_ == NULL) pubmsg_ = new ::gabriel::protocol::PubMsg;
  return pubmsg_;
}
inline ::gabriel::protocol::PubMsg* DB_Msg::release_pubmsg() {
  clear_has_pubmsg();
  ::gabriel::protocol::PubMsg* temp = pubmsg_;
  pubmsg_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_pubmsg(::gabriel::protocol::PubMsg* pubmsg) {
  delete pubmsg_;
  pubmsg_ = pubmsg;
  if (pubmsg) {
    set_has_pubmsg();
  } else {
    clear_has_pubmsg();
  }
}

// optional .gabriel.protocol.PubEnum pubenum = 8;
inline bool DB_Msg::has_pubenum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DB_Msg::set_has_pubenum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DB_Msg::clear_has_pubenum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DB_Msg::clear_pubenum() {
  pubenum_ = 999;
  clear_has_pubenum();
}
inline ::gabriel::protocol::PubEnum DB_Msg::pubenum() const {
  return static_cast< ::gabriel::protocol::PubEnum >(pubenum_);
}
inline void DB_Msg::set_pubenum(::gabriel::protocol::PubEnum value) {
  assert(::gabriel::protocol::PubEnum_IsValid(value));
  set_has_pubenum();
  pubenum_ = value;
}

// optional .gabriel.protocol.PubOuter pubouter = 9;
inline bool DB_Msg::has_pubouter() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DB_Msg::set_has_pubouter() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DB_Msg::clear_has_pubouter() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DB_Msg::clear_pubouter() {
  if (pubouter_ != NULL) pubouter_->::gabriel::protocol::PubOuter::Clear();
  clear_has_pubouter();
}
inline const ::gabriel::protocol::PubOuter& DB_Msg::pubouter() const {
  return pubouter_ != NULL ? *pubouter_ : *default_instance_->pubouter_;
}
inline ::gabriel::protocol::PubOuter* DB_Msg::mutable_pubouter() {
  set_has_pubouter();
  if (pubouter_ == NULL) pubouter_ = new ::gabriel::protocol::PubOuter;
  return pubouter_;
}
inline ::gabriel::protocol::PubOuter* DB_Msg::release_pubouter() {
  clear_has_pubouter();
  ::gabriel::protocol::PubOuter* temp = pubouter_;
  pubouter_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_pubouter(::gabriel::protocol::PubOuter* pubouter) {
  delete pubouter_;
  pubouter_ = pubouter;
  if (pubouter) {
    set_has_pubouter();
  } else {
    clear_has_pubouter();
  }
}

// optional .gabriel.protocol.PubOuter.PubInner pubinner = 10;
inline bool DB_Msg::has_pubinner() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DB_Msg::set_has_pubinner() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DB_Msg::clear_has_pubinner() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DB_Msg::clear_pubinner() {
  if (pubinner_ != NULL) pubinner_->::gabriel::protocol::PubOuter_PubInner::Clear();
  clear_has_pubinner();
}
inline const ::gabriel::protocol::PubOuter_PubInner& DB_Msg::pubinner() const {
  return pubinner_ != NULL ? *pubinner_ : *default_instance_->pubinner_;
}
inline ::gabriel::protocol::PubOuter_PubInner* DB_Msg::mutable_pubinner() {
  set_has_pubinner();
  if (pubinner_ == NULL) pubinner_ = new ::gabriel::protocol::PubOuter_PubInner;
  return pubinner_;
}
inline ::gabriel::protocol::PubOuter_PubInner* DB_Msg::release_pubinner() {
  clear_has_pubinner();
  ::gabriel::protocol::PubOuter_PubInner* temp = pubinner_;
  pubinner_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_pubinner(::gabriel::protocol::PubOuter_PubInner* pubinner) {
  delete pubinner_;
  pubinner_ = pubinner;
  if (pubinner) {
    set_has_pubinner();
  } else {
    clear_has_pubinner();
  }
}

// optional .gabriel.protocol.PubOuter.PubInnerEnum pubinnerenum = 11;
inline bool DB_Msg::has_pubinnerenum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DB_Msg::set_has_pubinnerenum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DB_Msg::clear_has_pubinnerenum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DB_Msg::clear_pubinnerenum() {
  pubinnerenum_ = 8;
  clear_has_pubinnerenum();
}
inline ::gabriel::protocol::PubOuter_PubInnerEnum DB_Msg::pubinnerenum() const {
  return static_cast< ::gabriel::protocol::PubOuter_PubInnerEnum >(pubinnerenum_);
}
inline void DB_Msg::set_pubinnerenum(::gabriel::protocol::PubOuter_PubInnerEnum value) {
  assert(::gabriel::protocol::PubOuter_PubInnerEnum_IsValid(value));
  set_has_pubinnerenum();
  pubinnerenum_ = value;
}

// optional .gabriel.protocol.OnePubMsg onepubmsg = 12;
inline bool DB_Msg::has_onepubmsg() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DB_Msg::set_has_onepubmsg() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DB_Msg::clear_has_onepubmsg() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DB_Msg::clear_onepubmsg() {
  if (onepubmsg_ != NULL) onepubmsg_->::gabriel::protocol::OnePubMsg::Clear();
  clear_has_onepubmsg();
}
inline const ::gabriel::protocol::OnePubMsg& DB_Msg::onepubmsg() const {
  return onepubmsg_ != NULL ? *onepubmsg_ : *default_instance_->onepubmsg_;
}
inline ::gabriel::protocol::OnePubMsg* DB_Msg::mutable_onepubmsg() {
  set_has_onepubmsg();
  if (onepubmsg_ == NULL) onepubmsg_ = new ::gabriel::protocol::OnePubMsg;
  return onepubmsg_;
}
inline ::gabriel::protocol::OnePubMsg* DB_Msg::release_onepubmsg() {
  clear_has_onepubmsg();
  ::gabriel::protocol::OnePubMsg* temp = onepubmsg_;
  onepubmsg_ = NULL;
  return temp;
}
inline void DB_Msg::set_allocated_onepubmsg(::gabriel::protocol::OnePubMsg* onepubmsg) {
  delete onepubmsg_;
  onepubmsg_ = onepubmsg;
  if (onepubmsg) {
    set_has_onepubmsg();
  } else {
    clear_has_onepubmsg();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace server
}  // namespace protocol
}  // namespace gabriel

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gabriel::protocol::server::Outer_InnerEnum>() {
  return ::gabriel::protocol::server::Outer_InnerEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gabriel::protocol::server::OuterEnum>() {
  return ::gabriel::protocol::server::OuterEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gabriel_2fprotocol_2fserver_2fdb_2eproto__INCLUDED
